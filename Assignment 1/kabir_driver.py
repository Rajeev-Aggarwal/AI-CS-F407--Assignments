import turtle
import random
from kabir_vacum import *
import sys
import pylab
import time
wn = turtle.Screen()
wn.bgcolor("white")
wn.title("Floor")
wn.setup(1200,1200)
sys.setrecursionlimit(10000)

class Pen(turtle.Turtle):
    def __init__(self):
        turtle.Turtle.__init__(self)
        self.shape("square")
        self.color("black")
        self.penup()
        self.speed(0)
        
class PenDirt(turtle.Turtle):
    def __init__(self):
        turtle.Turtle.__init__(self)
        self.shape("square")
        self.color("yellow")
        self.penup()
        self.speed(0)

class DirtTracer(turtle.Turtle):
    def __init__(self):
        turtle.Turtle.__init__(self)
        self.shape("circle")
        self.pensize(4)
        self.color("blue")
        self.penup()
        self.speed(4)


def draw_floor(mat,xcor,ycor):
    for y in range(len(mat)):
        for x in range(len(mat[y])):
            a = mat[y][x]
            screen_x = -xcor + (x*30)
            screen_y = ycor- (y*30)
            
            if a == 0:
                pen.turtlesize(1.2,1.2)
                pen.goto(screen_x,screen_y)
                pen.stamp()
            if a == 1:
                dirt.turtlesize(1.2,1.2)
                dirt.goto(screen_x,screen_y)
                dirt.stamp()

def trace_path(path,initial_pos,xcor,ycor,color='red'):
    x,y = initial_pos

    
    screen_x = -xcor + (x*30)
    screen_y = ycor- (y*30)
    trace.goto(screen_x,screen_y)
    trace.stamp()
    trace.color(color)
    

    for pos in path:
        x,y = pos
        screen_x = -xcor + (y*30)
        screen_y = ycor - (x*30)
        trace.pendown()
        trace.goto(screen_x,screen_y)

n = 10
p = 0.5
floor = tiled_floor(n)
floor.generate_dirt(p)

pen = Pen()
dirt = PenDirt()
trace = DirtTracer()
def option1():
    draw_floor(floor.mat,500,320)
#option1()
agent_env = copy.deepcopy(floor)
agent_un = Intelligent_Agent(agent_env,(0,0,agent_env))
agent_h = Intelligent_Agent2(agent_env,(0,0,agent_env))
agent_h2 = Intelligent_Agent2(agent_env,(0,0,agent_env))
start = time.clock()
agent_un.search((0,0,agent_env),0,500)
t_un = time.clock() - start
agent_un.follow_path()
c_un = agent_un.cost

start = time.clock()
agent_h.search((0,0,agent_env),0,(1+3*p)*(n**2),'h1')
t_h1 = time.clock() - start
agent_h.follow_path()
c_h1 = agent_h.cost
start = time.clock()
agent_h2.search((0,0,agent_env),0,(1+3*p)*(n**2),'h2')
t_h2 = time.clock() - start
agent_h2.follow_path()
c_h2 = agent_h2.cost

def option2():
    print "T1 analysis"
    print "Path obtained from Uninformed Search:"
    print agent_un.path[::-1]
    print "Number of nodes generated by Uninformed Search ",agent_un.num_nodes
    memory = agent_un.num_nodes*(4.0*100+8)/(1024.0*1024)
    print "Amount of memory occupied by nodes ",memory,' mbs'
    print "Maximum depth of Implicit Stack ",agent_un.depth
    print "Cost of cleaning the room ",c_un
    print "Time taken to compute the path " + str(t_un*(10**3)) + " ms" 

def option3():

    print "T2 analysis"
    print "Path obtained from Informed Search heuristic1:"
    print agent_h.path[::-1]
    print "Path obtained from Informed Search heuristic2:"
    print agent_h2.path[::-1]
    print "Number of nodes generated by Informed Search by heuristic 1",agent_h.num_nodes
    print "Number of nodes generated by Informed Search by heuristic 2",agent_h2.num_nodes
    memoryh1 = agent_h.num_nodes*(4.0*100+8)/(1024.0*1024)
    print "Amount of memory occupied by nodes heuristic 1 " +str(memoryh1)+' mbs'
    memoryh2 = agent_h2.num_nodes*(4.0*100+8)/(1024.0*1024)
    print "Amount of memory occupied by nodes heuristic 2 " +str(memoryh2)+' mbs'
    print "Maximum depth of Implicit Stack heuristic 1 ",agent_h.depth
    print "Maximum depth of Implicit Stack heuristic 2 ",agent_h2.depth
    print "Cost of cleaning the room heuristic 1",c_h1
    print "Cost of cleaning the room heuristic 2",c_h2
    print "Time taken to compute the path heuristic 1 " + str(t_h1*(10**3)) + " ms"
    print "Time taken to compute the path heuristic 2 " + str(t_h2*(10**3)) + " ms" 



def option4():
    p = 0.2
    draw_floor(floor.mat,140,320)
    path = (agent_un.positions[::-1])
    trace_path(path,(0,0),140,320)
    trace.stamp()
    trace.color('blue')
    trace.penup()
    path = (agent_h.positions[::-1])

    draw_floor(floor.mat,-260,320)
    trace_path(path,(0,0),-260,320)
    path = (agent_h2.positions[::-1])
    trace.color('blue')
    trace.penup()
    trace_path(path,(0,0),-260,320,'green')
    N = list(range(3,21))
    t1 = []
    t2 = []
    for x in N:
        n = x
        start = time.clock()
        agent_h.search((0,0,agent_env),0,(1+3*p)*(n**2),'h1')
        t1.append((time.clock()-start))
        start = time.clock()
        agent_h2.search((0,0,agent_env),0,(1+3*p)*(n**2),'h2')
        t2.append((time.clock()- start))
    #Comment out in case Pylab is not present    
    pylab.figure(1)
    pylab.plot(N,t1,'r',label='Heuristic1')
    pylab.plot(N,t2,'g',label = 'Heuristic2')
    pylab.legend(loc='upper left')
    pylab.title('Time taken vs size of grid')
    pylab.savefig('foo.png')

    i = 0.1
    n = 10
    pt = []
    P = []
    while i <=1:
        P.append(i)
        i+=0.05
    for p in P:
        start = time.clock()
        agent_h.search((0,0,agent_env),0,(1+3*p)*(n**2),'h1')
        pt.append(time.clock() - start) 

    #Comment out in case Pylab is not present     
    pylab.figure(2)
    pylab.plot(P,pt,label = 'amount of d')
    pylab.legend(loc='upper left')
    pylab.title('Time taken vs amount of dirt')
    pylab.show()
    pylab.savefig('foo1.png')
    while True:
        pass

option1()
option2()
option3()
option4()